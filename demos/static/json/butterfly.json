[{"id": 1, "name": "BoidObject.as", "content": "/**\n * www.GameCheetah.net\n * Boid implementation adapted from http://www.kfish.org/boids/pseudocode.html\n * \n * The MIT License (MIT)\n * \n * Copyright (c) <2015> <Zeb Zhao>\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage \n{\n\timport flash.geom.Point;\n\timport flash.geom.Vector3D;\n\timport gamecheetah.Entity;\n\t\n\tpublic class BoidObject extends Entity \n\t{\n\t\t/**\n\t\t * How far the object can see. Only things within its sight will affect its movement.\n\t\t */\n\t\tpublic var sight:Number = 150;\n\t\t\n\t\t/**\n\t\t * Mass, the heavier the boid relative to other boids, the more objects will flock around it.\n\t\t */\n\t\tpublic var mass:Number = 1;\n\t\t\n\t\t/**\n\t\t * How big the object is, controls how much distance to put between other boids.\n\t\t */\n\t\tpublic var diameter:Number = 75;\n\t\t\n\t\t/**\n\t\t * How fast the object moves.\n\t\t */\n\t\tpublic var speed:Number = 5;\n\t\t\n\t\t/**\n\t\t * Virtual velocity of the boid.\n\t\t */\n\t\tpublic var velocity:Vector3D = new Vector3D;\n\t\t\n\t\t/**\n\t\t * Virtual position of the boid.\n\t\t */\n\t\tpublic var position:Vector3D = new Vector3D;\n\t\t\n\t\t/**\n\t\t * If true, boids will try and stay above the min bounds.\n\t\t */\n\t\tpublic var minBounds:Vector3D;\n\t\t\n\t\t/**\n\t\t * If true, boids will try and stay above the min bounds.\n\t\t */\n\t\tpublic var maxBounds:Vector3D;\n\t\t\n\t\t/**\n\t\t * If non zero, this is the scaling factor used for z-position.\n\t\t */\n\t\tpublic var zScalingFactor:Number = 0;\n\t\t\n\t\t/**\n\t\t * The vanishing point on the screen.\n\t\t */\n\t\tpublic var fusionPoint:Point;\n\t\t\n\t\t\n\t\toverride public function onActivate():void \n\t\t{\n\t\t\tif (!fusionPoint)\n\t\t\t\tthis.fusionPoint = new Point(this.space.screenBounds.width / 2, this.space.screenBounds.height / 2);\n\t\t\t\t\n\t\t\tthis.position.setTo(this.location.x - this.fusionPoint.x, this.location.y - this.fusionPoint.y, 0);\n\t\t\tthis.clip.smoothing = true;\n\t\t}\n\t\t\n\t\toverride public function onUpdate():void \n\t\t{\n\t\t\tvar buddies:Vector.<Entity> = this.space.queryArea(this.position.x - sight / 2, this.position.y - sight / 2, sight, sight);\n\t\t\tbuddies = buddies.filter(filterBySight);\n\t\t\t\n\t\t\tif (buddies.length > 0)\n\t\t\t{\n\t\t\t\tthis.velocity.incrementBy(ruleFindBuddies(buddies));\n\t\t\t\tthis.velocity.incrementBy(ruleAvoidBuddies(buddies));\n\t\t\t\tthis.velocity.incrementBy(ruleFollowBuddies(buddies));\n\t\t\t}\n\t\t\t\n\t\t\tif (minBounds && maxBounds)\n\t\t\t{\n\t\t\t\tthis.velocity.incrementBy(ruleStayOnScreen());\n\t\t\t}\n\t\t\t\n\t\t\tthis.velocity.scaleBy(speed / this.velocity.length);\n\t\t\tthis.position.incrementBy(this.velocity);\n\t\t\t\n\t\t\tif (zScalingFactor > 0)\n\t\t\t{\n\t\t\t\tvar zScaling:Number = zScalingFactor / this.position.z;\n\t\t\t\t// Update scale of clip\n\t\t\t\tthis.renderable.scaleX = this.renderable.scaleY = zScaling;\n\t\t\t\t// Update the render depth according to z position\n\t\t\t\tthis.depth = int(1000 * zScaling);\n\t\t\t\t// Project x, y according to z position\n\t\t\t\tthis.setCenter(this.position.x * zScaling + this.fusionPoint.x, this.position.y * zScaling + this.fusionPoint.y);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Set location with no z-scaling.\n\t\t\t\tthis.setCenter(this.position.x, this.position.y);\n\t\t\t}\n\t\t}\n\t\t\n\t\t/**\n\t\t * Filter function to filter out non-boids, self and out-of-sight boids.\n\t\t */\n\t\tprivate\tfunction filterBySight(entity:Entity, index:int, arr:Vector.<Entity>):Boolean\n\t\t{\n\t\t\treturn entity != this && entity is BoidObject && (entity as BoidObject).position.subtract(this.position).length < this.sight; \n\t\t}\n\t\t\n\t\t/**\n\t\t * Rule that calculates the velocity to move towards nearby average buddy position.\n\t\t */\n\t\tprivate function ruleFindBuddies(buddies:Vector.<Entity>):Vector3D \n\t\t{\n\t\t\tvar avgPosition:Vector3D = new Vector3D;  // Mass average of nearby boid position.\n\t\t\tvar totalMass:Number = 0;  // Keeps track of the sum of the total surrounding boid mass.\n\t\t\tvar totalBoids:int;  // Keeps track of total number of nearby boids.\n\t\t\tvar v:Vector3D = new Vector3D();  // Temporary vector\n\t\t\t\n\t\t\tvar entity:Entity, boid:BoidObject;\n\t\t\tfor each (entity in buddies)\n\t\t\t{\n\t\t\t\tboid = entity as BoidObject;\n\t\t\t\tv.copyFrom(boid.position);\n\t\t\t\tv.scaleBy(boid.mass);\n\t\t\t\tavgPosition.incrementBy(v);\n\t\t\t\ttotalMass += boid.mass;\n\t\t\t\ttotalBoids++;\n\t\t\t}\n\t\t\tavgPosition.scaleBy(1 / totalMass);\n\t\t\t\n\t\t\tvar avgVelocity:Vector3D = avgPosition.subtract(this.position);\n\t\t\tavgVelocity.scaleBy(1 / 100);\n\t\t\t\n\t\t\treturn avgVelocity;\n\t\t}\n\t\t\n\t\t/**\n\t\t * Rule to avoid colliding into nearby buddies.\n\t\t */\n\t\tprivate function ruleAvoidBuddies(buddies:Vector.<Entity>):Vector3D \n\t\t{\n\t\t\tvar avgPosition:Vector3D = new Vector3D;  // Mass average of nearby boid position.\n\t\t\tvar totalBoids:int;  // Keeps track of total number of nearby boids.\n\t\t\tvar totalDiameter:Number = 0;  // Keeps track of total diameter of nearby boids.\n\t\t\tvar v:Vector3D = new Vector3D();  // Temporary vector\n\t\t\t\n\t\t\tvar entity:Entity, boid:BoidObject;\n\t\t\tfor each (entity in buddies)\n\t\t\t{\n\t\t\t\tboid = entity as BoidObject;\n\t\t\t\tif (boid.position.subtract(this.position).length < boid.diameter/2 + this.diameter/2)\n\t\t\t\t{\n\t\t\t\t\tv.copyFrom(boid.position);\n\t\t\t\t\tv.decrementBy(this.position);\n\t\t\t\t\tv.scaleBy(boid.diameter);\n\t\t\t\t\tavgPosition.decrementBy(v);\n\t\t\t\t\ttotalDiameter += boid.diameter;\n\t\t\t\t\ttotalBoids++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (totalDiameter > 0) avgPosition.scaleBy(1 / totalDiameter);\n\t\t\t\n\t\t\treturn avgPosition;\n\t\t}\n\t\t\n\t\t/**\n\t\t * Rule to match nearby buddy velocities.\n\t\t */\n\t\tprivate function ruleFollowBuddies(buddies:Vector.<Entity>):Vector3D \n\t\t{\n\t\t\tvar avgVelocity:Vector3D = new Vector3D;  // Mass average of nearby boid position.\n\t\t\tvar totalBoids:int;  // Keeps track of total number of nearby boids.\n\t\t\tvar v:Vector3D = new Vector3D();  // Temporary vector\n\t\t\t\n\t\t\tvar entity:Entity, boid:BoidObject;\n\t\t\tfor each (entity in buddies)\n\t\t\t{\n\t\t\t\tboid = entity as BoidObject;\n\t\t\t\tv.copyFrom(boid.velocity);\n\t\t\t\tavgVelocity.incrementBy(v);\n\t\t\t\ttotalBoids++;\n\t\t\t}\n\t\t\tavgVelocity.scaleBy(1 / totalBoids);\n\t\t\t\n\t\t\tv = this.velocity.subtract(avgVelocity);\n\t\t\tv.scaleBy(1 / 8);\n\t\t\treturn v;\n\t\t}\n\t\t\n\t\t/**\n\t\t * Rule to match nearby buddy velocities.\n\t\t */\n\t\tprivate function ruleStayOnScreen():Vector3D \n\t\t{\n\t\t\tvar v:Vector3D = new Vector3D;\n\t\t\t\n\t\t\tif (this.position.x < minBounds.x)\n\t\t\t{\n\t\t\t\tv.x += minBounds.x - this.position.x;\n\t\t\t}\n\t\t\telse if (this.position.x > maxBounds.x)\n\t\t\t{\n\t\t\t\tv.x += maxBounds.x - this.position.x;\n\t\t\t}\n\t\t\tif (this.position.y < minBounds.y)\n\t\t\t{\n\t\t\t\tv.y += minBounds.y - this.position.y;\n\t\t\t}\n\t\t\telse if (this.position.y > maxBounds.y)\n\t\t\t{\n\t\t\t\tv.y += maxBounds.y - this.position.y;\n\t\t\t}\n\t\t\tif (this.position.z < minBounds.z)\n\t\t\t{\n\t\t\t\tv.z += minBounds.z - this.position.z;\n\t\t\t}\n\t\t\telse if (this.position.z > maxBounds.z)\n\t\t\t{\n\t\t\t\tv.z += maxBounds.z - this.position.z;\n\t\t\t}\n\t\t\tv.scaleBy(1 / 100);\n\t\t\treturn v;\n\t\t}\n\t}\n\n}"}, {"id": 2, "name": "Butterfly.as", "content": "package \n{\n\timport flash.geom.Vector3D;\n\t\n\tpublic class Butterfly extends BoidObject \n\t{\n\t\tpublic static var flapPatternNames:Object = {\"0\": \"flap\", \"1\": \"flutter\", \"2\": \"reverse\"};\n\t\tpublic var flapPattern:int;\n\t\tpublic var flapPatternDuration:int;\n\t\t\n\t\tpublic function Butterfly() \n\t\t{\n\t\t\tthis.mass = 1;\n\t\t\tthis.speed = 3.5;\n\t\t\tthis.diameter = 50;\n\t\t\tthis.sight = 100;\n\t\t\tthis.zScalingFactor = 1200;\n\t\t}\n\t\t\n\t\toverride public function onActivate():void \n\t\t{\n\t\t\tsuper.onActivate();\n\t\t\t\n\t\t\t// Set virtual z-position.\n\t\t\tthis.position.z = Math.random() * 500 + 950;\n\t\t\t// Set virtual bounds for motion.\n\t\t\tthis.minBounds = new Vector3D(-300, -300, 900);\n\t\t\tthis.maxBounds = new Vector3D(300, 300, 1500);\n\t\t\t\n\t\t\t// Play a random flap animation.\n\t\t\tthis.flapPattern = int(Math.random() * 3);\n\t\t\tthis.flapPatternDuration = int(Math.random() * 60);\n\t\t\tthis.clip.play(flapPatternNames[this.flapPattern]);\n\t\t\t\n\t\t\t// Fly upwards initially\n\t\t\tthis.tweenClip( { \"alpha\": 0 }, { \"alpha\": 1 } );\n\t\t\tthis.velocity.setTo(Math.random() * 0.2 - 0.1, -1, Math.random());\n\t\t\tthis.velocity.normalize();\n\t\t\tthis.velocity.scaleBy(speed);\n\t\t}\n\t\t\n\t\toverride public function onUpdate():void \n\t\t{\n\t\t\tsuper.onUpdate();\n\t\t\t\n\t\t\tthis.flapPatternDuration--;\n\t\t\t\n\t\t\t// Switch flap pattern animation, wait till animation is on the first frame.\n\t\t\tif (flapPatternDuration <= 0 && this.clip.index == 0)\n\t\t\t{\n\t\t\t\tthis.flapPattern = int(Math.random() * 3);\n\t\t\t\tthis.flapPatternDuration = int(Math.random() * 150 + 30);\n\t\t\t\t// Play a random animation.\n\t\t\t\tthis.clip.play(flapPatternNames[this.flapPattern]);\n\t\t\t}\n\t\t\t\n\t\t\t// Horizontally flip the clip if flying left.\n\t\t\tthis.clip.hFlipped = this.velocity.x < 0;\n\t\t}\n\t}\n\n}"}, {"id": 3, "name": "Main.as", "content": "package\n{\n\timport flash.display.StageAlign;\n\timport flash.display.StageScaleMode;\n\timport flash.geom.Point;\n\timport gamecheetah.Engine\n\t\n\tpublic class Main extends Engine \n\t{\n\t\t// Embed assets to automatically load resources on building SWF.\n\t\t[Embed(source = \"../resource.amf\", mimeType = \"application/octet-stream\")]\n\t\tprivate static var Resources:Class;\n\t\t\n\t\tpublic function Main() \n\t\t{\n\t\t\tsuper(60);  // Launch game at 60 fps\n\t\t}\n\t\t\n\t\toverride public function onEnter():void \n\t\t{\n\t\t\t// Register Entity classes with the Designer\n\t\t\tEngine.registerEntity(Butterfly);\n\t\t\tEngine.registerEntity(SimpleButton);\n\t\t\t// Register Space classes with the Designer\n\t\t\tEngine.registerSpace(MainSpace);\n\t\t\t// Load resource file\n\t\t\tEngine.loadEmbeddedFile(Resources);\n\t\t\t// Fix screen size\n\t\t\tthis.setSize(new Point(450, 450));\n\t\t}\n\t}\n\t\n}"}, {"id": 4, "name": "MainSpace.as", "content": "package \n{\n\timport flash.geom.Point;\n\timport gamecheetah.Space;\n\timport gamecheetah.Engine;\n\t\n\tpublic class MainSpace extends Space \n\t{\n\t\tpublic var butterflies:Vector.<Butterfly> = new Vector.<Butterfly>();\n\t\tpublic var bottle: SimpleButton;\n\t\tpublic var play: SimpleButton;\n\t\t\n\t\tpublic function MainSpace() \n\t\t{\n\t\t\tsuper();\n\t\t}\n\t\t\n\t\toverride public function onEnter():void \n\t\t{\n\t\t\t// Enable mouse interaction for the space.\n\t\t\tthis.mouseEnabled = true;\n\t\t\t\n\t\t\t// Fetch buttons created in the designer and assign functionality.\n\t\t\tplay = this.getByTag(\"PlayButton\")[0] as SimpleButton;\n\t\t\tplay.setOverState(null, { \"alpha\": 0.5 } );\n\t\t\tplay.setOutState(null, { \"alpha\": 1 } );\n\t\t\tplay.setDownState(\"activate\", null, resetGame);\n\t\t\tbottle = this.getByTag(\"Bottle\")[0] as SimpleButton;\n\t\t\tplay.depth = 1000;\n\t\t\tbottle.setDownState(\"open\", null, bottle_onMouseDown);\n\t\t\tbottle.setOverState(null, { \"alpha\": 0.5 } );\n\t\t\tbottle.setOutState(null, { \"alpha\": 1 }, bottle_onMouseOut);\n\t\t\tbottle.depth = 1000;\n\t\t}\n\t\t\n\t\tprivate function resetGame(...args):void \n\t\t{\n\t\t\tfor each (var butterfly:Butterfly in butterflies) this.destroyEntity(butterfly);\n\t\t\tbutterflies.length = 0;\n\t\t}\n\t\t\n\t\tprivate function createButterfly(x:Number, y:Number):void \n\t\t{\n\t\t\tbutterflies.push(this.createEntity(\"butterfly\", new Point(x, y)));\n\t\t}\n\t\t\n\t\tprivate function bottle_onMouseDown(btn:SimpleButton):void \n\t\t{\n\t\t\tif (butterflies.length == 0)\n\t\t\t{\n\t\t\t\t// Create 2 butterflies initially!\n\t\t\t\tEngine.startInvoke(Math.random() * 15 + 15, createButterfly, [btn.center.x, btn.center.y - 10]);\n\t\t\t}\n\t\t\tcreateButterfly(btn.center.x, btn.center.y - 10);\n\t\t}\n\t\t\n\t\tprivate function bottle_onMouseOut(btn:SimpleButton):void \n\t\t{\n\t\t\tif (btn.clip.animationName == \"open\") btn.clip.play(\"close\");\n\t\t}\n\t}\n\n}"}, {"id": 5, "name": "SimpleButton.as", "content": "package \n{\n\timport gamecheetah.Entity;\n\t\n\tpublic class SimpleButton extends Entity \n\t{\n\t\t//{ ------------------- Private Info -------------------\n\t\t\n\t\tprivate var\n\t\t\t_downTweenTo:Object, _upTweenTo:Object, _overTweenTo:Object, _outTweenTo:Object,\n\t\t\t_mouseDown:Function, _mouseUp:Function, _mouseOver:Function, _mouseOut:Function,\n\t\t\t_downAnimation:String, _upAnimation:String, _overAnimation:String, _outAnimation:String;\n\t\t\n\t\t//{ ------------------- Public Methods -------------------\n\t\t\n\t\tpublic function setDownState(animation:String, tweenTo:Object=null, handler:Function=null):void \n\t\t{\n\t\t\t_downAnimation = animation;\n\t\t\t_downTweenTo = tweenTo;\n\t\t\t_mouseDown = handler;\n\t\t}\n\t\t\n\t\tpublic function setUpState(animation:String, tweenTo:Object=null, handler:Function=null):void \n\t\t{\n\t\t\t_upAnimation = animation;\n\t\t\t_upTweenTo = tweenTo;\n\t\t\t_mouseUp = handler;\n\t\t}\n\t\t\n\t\tpublic function setOverState(animation:String, tweenTo:Object=null, handler:Function=null):void \n\t\t{\n\t\t\t_overAnimation = animation;\n\t\t\t_overTweenTo = tweenTo;\n\t\t\t_mouseOver = handler;\n\t\t}\n\t\t\n\t\tpublic function setOutState(animation:String, tweenTo:Object=null, handler:Function=null):void \n\t\t{\n\t\t\t_outAnimation = animation;\n\t\t\t_outTweenTo = tweenTo;\n\t\t\t_mouseOut = handler;\n\t\t}\n\t\t\n\t\t//{ ------------------- Behaviour Overrides -------------------\n\t\t\n\t\toverride public function onActivate():void \n\t\t{\n\t\t\tthis.mouseEnabled = true;\n\t\t\tthis.clip.smoothing = true;\n\t\t}\n\t\t\n\t\toverride public function onMouseDown():void \n\t\t{\n\t\t\tif (_downAnimation)\t\tthis.clip.play(_downAnimation, true);\n\t\t\tif (_downTweenTo) \t\tthis.tweenClip(null, _downTweenTo);\n\t\t\tif (_mouseDown) \t\t_mouseDown(this);\n\t\t}\n\t\t\n\t\toverride public function onMouseUp():void \n\t\t{\n\t\t\tif (_upAnimation)\t\tthis.clip.play(_upAnimation, true);\n\t\t\tif (_upTweenTo) \t\tthis.tweenClip(null, _upTweenTo);\n\t\t\tif (_mouseUp) \t\t\t_mouseUp(this);\n\t\t}\n\t\t\n\t\toverride public function onMouseOver():void \n\t\t{\n\t\t\tif (_overAnimation)\t\tthis.clip.play(_overAnimation, true);\n\t\t\tif (_overTweenTo) \t\tthis.tweenClip(null, _overTweenTo);\n\t\t\tif (_mouseOver) \t\t_mouseOver(this);\n\t\t}\n\t\t\n\t\toverride public function onMouseOut():void \n\t\t{\n\t\t\tif (_outAnimation)\t\tthis.clip.play(_outAnimation, true);\n\t\t\tif (_outTweenTo) \t\tthis.tweenClip(null, _outTweenTo);\n\t\t\tif (_mouseOut) \t\t\t_mouseOut(this);\n\t\t}\n\t}\n}"}]
